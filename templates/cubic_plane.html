<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Physicsium - Cubic Crystal Builder with Plane (Fixed)</title>

<!-- GlowScript CSS (kept from your original) -->
<link rel="stylesheet" href="https://www.glowscript.org/css/redmond/2.1/jquery-ui.custom.css" />
<link rel="stylesheet" href="https://www.glowscript.org/css/ide.css" />

<!-- GlowScript & jQuery -->
<script src="https://www.glowscript.org/lib/jquery/2.1/jquery.min.js"></script>
<script src="https://www.glowscript.org/lib/jquery/2.1/jquery-ui.custom.min.js"></script>
<script src="https://www.glowscript.org/package/glow.3.2.min.js"></script>
<script src="https://www.glowscript.org/package/RSrun.3.2.min.js"></script>

<style>
  body {
    background: linear-gradient(135deg, #1e3c72, #2a5298);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    align-items: center;
    justify-content: flex-start;
    padding: 2rem;
    margin: 0;
  }
  h1 {
    font-size: 2.2rem;
    margin-bottom: 1rem;
    font-weight: 700;
    text-shadow: 0 0 6px rgba(255,255,255,0.4);
  }
  form {
    background: rgba(255, 255, 255, 0.07);
    padding: 16px 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(90, 200, 250, 0.35);
    margin-bottom: 1rem;
    width: 100%;
    max-width: 520px;
  }
  label, select, input {
    font-size: 1rem;
    display: block;
    margin: 8px 0 6px 0;
    color: #cce0ffcc;
  }
  select, input[type=number], input[type=text] {
    width: 100%;
    padding: 8px 10px;
    font-size: 1rem;
    border-radius: 6px;
    border: none;
    outline: none;
    background: rgba(255, 255, 255, 0.15);
    color: white;
  }
  button {
    background: rgba(255,255,255,0.06);
    border: 2px solid #5ac8fa;
    border-radius: 10px;
    padding: 10px 14px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    color: white;
    margin-right: 8px;
  }
  #glowscript {
    width: 100%;
    max-width: 980px;
    height: 600px;
    border-radius: 10px;
    box-shadow: 0 0 16px rgba(90, 200, 250, 0.45);
    border: 2px solid #5ac8fa;
  }
  #crystalType {
    color: black; /* dropdown text color */
  }
  #crystalType option {
    color: black; /* options text color */
  }
  .plane-error {
    color: #ff6b6b;
    font-weight: 700;
    margin-top: 6px;
  }
</style>
</head>
<body>

<h1>Physicsium - Cubic Crystal Builder with Plane (Fixed)</h1>

<form id="crystalForm">
  <label for="crystalType">Select Cubic Crystal Type:</label>
  <select id="crystalType">
    <option value="sc">Simple Cubic (SC)</option>
    <option value="bcc">Body-Centered Cubic (BCC)</option>
    <option value="fcc">Face-Centered Cubic (FCC)</option>
  </select>

  <label for="numCells">Number of Unit Cells per Side (1 to 6):</label>
  <input type="number" id="numCells" value="3" min="1" max="6" step="1" />

  <hr style="margin: 12px 0; border-color: #5ac8fa66;" />

  <label>Miller Indices for Plane (h, k, l):</label>
  <input type="text" id="hIndex" placeholder="h (e.g. 1 or -1 or 1/2)" value="1" />
  <input type="text" id="kIndex" placeholder="k (e.g. 0 or 1/3)" value="1" />
  <input type="text" id="lIndex" placeholder="l (e.g. 0 or -2)" value="1" />
  <div id="planeError" class="plane-error" style="display:none;"></div>

  <div style="margin-top:10px;">
    <button type="button" id="createBtn">Create Crystal</button>
    <button type="button" id="drawPlaneBtn">Draw Plane</button>
    <button type="button" id="clearBtn">Clear</button>
  </div>
</form>

<div id="glowscript" class="glowscript"></div>

<footer style="margin-top:12px; color:#cce0ffaa;">&copy; 2025 Physicsium</footer>

<script type="text/javascript">
(function () {
  async function __main__() {
    // initialize canvas in the target div
    let scene = canvas();
    scene.title = "Cubic Crystal Viewer with Plane";
    scene.range = 8;
    scene.background = vec(0.08, 0.12, 0.18);

    // small axes
    const axisLength = 6;
    const axisThickness = 0.04;
    box({ pos: vec(axisLength / 2, 0, 0), size: vec(axisLength, axisThickness, axisThickness), color: color.red });
    box({ pos: vec(0, axisLength / 2, 0), size: vec(axisThickness, axisLength, axisThickness), color: color.green });
    box({ pos: vec(0, 0, axisLength / 2), size: vec(axisThickness, axisThickness, axisLength), color: color.blue });

    let atoms = [];
    let planeObj = null;
    const latticeA = 1.0; // lattice constant

    function clearAtoms() {
      for (let a of atoms) {
        try { a.visible = false; } catch(e) {}
        if (a.delete) a.delete();
      }
      atoms = [];
    }
    function clearPlane() {
      if (planeObj) {
        try { planeObj.visible = false; } catch(e) {}
        if (planeObj.delete) planeObj.delete();
        planeObj = null;
      }
    }

    function createSC(numCells) {
      clearAtoms();
      clearPlane();
      const a = latticeA;
      const r = a / 2.0;
      for (let x = 0; x < numCells; x++) {
        for (let y = 0; y < numCells; y++) {
          for (let z = 0; z < numCells; z++) {
            atoms.push(sphere({
              pos: vec(x * a, y * a, z * a),
              radius: r,
              color: color.orange,
              opacity: 1,
            }));
          }
        }
      }
    }

    function createBCC(numCells) {
      clearAtoms();
      clearPlane();
      const a = latticeA;
      const r = (Math.sqrt(3) * a) / 4;
      for (let x = 0; x < numCells; x++) {
        for (let y = 0; y < numCells; y++) {
          for (let z = 0; z < numCells; z++) {
            atoms.push(sphere({
              pos: vec(x * a, y * a, z * a),
              radius: r,
              color: color.cyan,
              opacity: 1,
            }));
            // body center inside cell (avoid duplicate on last cells)
            if (x < numCells - 1 && y < numCells - 1 && z < numCells - 1) {
              atoms.push(sphere({
                pos: vec(x * a + a / 2, y * a + a / 2, z * a + a / 2),
                radius: r,
                color: color.cyan,
                opacity: 1,
              }));
            }
          }
        }
      }
    }

    function createFCC(numCells) {
      clearAtoms();
      clearPlane();
      const a = latticeA;
      const r = a * ( Math.sqrt(2)/4);
      for (let x = 0; x < numCells; x++) {
        for (let y = 0; y < numCells; y++) {
          for (let z = 0; z < numCells; z++) {
            atoms.push(sphere({
              pos: vec(x * a, y * a, z * a),
              radius: r,
              color: color.magenta,
              opacity: 1,
            }));
            // face centers (three per cell)
            if (x < numCells - 1 && y < numCells - 1) {
              atoms.push(sphere({
                pos: vec(x * a + a / 2, y * a + a / 2, z * a),
                radius: r,
                color: color.magenta,
                opacity: 1,
              }));
            }
            if (x < numCells - 1 && z < numCells - 1) {
              atoms.push(sphere({
                pos: vec(x * a + a / 2, y * a, z * a + a / 2),
                radius: r,
                color: color.magenta,
                opacity: 1,
              }));
            }
            if (y < numCells - 1 && z < numCells - 1) {
              atoms.push(sphere({
                pos: vec(x * a, y * a + a / 2, z * a + a / 2),
                radius: r,
                color: color.magenta,
                opacity: 1,
              }));
            }
          }
        }
      }
    }

    // parse fraction like "1/2" or plain numbers
    function parseFraction(str) {
      if (typeof str !== 'string') str = String(str);
      str = str.trim();
      if (str === '') return NaN;
      if (str.includes('/')) {
        let parts = str.split('/');
        if (parts.length === 2) {
          let num = parseFloat(parts[0]);
          let den = parseFloat(parts[1]);
          if (!isNaN(num) && !isNaN(den) && den !== 0) return num / den;
        }
        return NaN;
      } else {
        return parseFloat(str);
      }
    }

    // Small, explicit vector helpers that always return VPython vec
    function vadd(u, v) { return vec(u.x + v.x, u.y + v.y, u.z + v.z); }
    function vsub(u, v) { return vec(u.x - v.x, u.y - v.y, u.z - v.z); }
    function vmul(u, s) { return vec(u.x * s, u.y * s, u.z * s); }
    function vdot(u, v) { return u.x * v.x + u.y * v.y + u.z * v.z; }
    function vcross(u, v) { return vec(u.y * v.z - u.z * v.y, u.z * v.x - u.x * v.z, u.x * v.y - u.y * v.x); }
    function vmag(u) { return Math.sqrt(vdot(u, u)); }
    function vnorm(u) { let m = vmag(u); return (m === 0) ? vec(0, 0, 0) : vmul(u, 1 / m); }

    // Robust drawPlane using Miller indices as normal (h,k,l),
    // plane equation: h*x + k*y + l*z = a  (a = lattice constant)
    function drawPlane(h, k, l, a = latticeA, numCells = 3) {
      clearPlane();
      if (isNaN(h) || isNaN(k) || isNaN(l)) return;
      if (h === 0 && k === 0 && l === 0) return;

      // Normal (VPython vec)
      let N = vec(h, k, l);
      let Nmag2 = h * h + k * k + l * l;
      if (Nmag2 === 0) return;

      // Crystal center (so the plane appears near the lattice)
      let centerPt = vec((numCells - 1) * a / 2, (numCells - 1) * a / 2, (numCells - 1) * a / 2);

      // Project center onto plane to get a point on the plane:
      // find t where center + t*N is on plane: N·(center + t*N) = a
      let dotC = vdot(N, centerPt);
      let t = (a - dotC) / Nmag2;
      let pointOnPlane = vadd(centerPt, vmul(N, t));

      // Choose a vector 'u' not parallel to N
      const candidates = [vec(1, 0, 0), vec(0, 1, 0), vec(0, 0, 1)];
      let u = candidates[0];
      for (let c of candidates) {
        // angle check: if dot(c, N)/|N| is small, c is not parallel
        if (Math.abs(vdot(c, N) / Math.sqrt(Nmag2)) < 0.9) {
          u = c;
          break;
        }
      }

      // Build two orthonormal vectors in the plane
      let v1 = vcross(u, N);
      let v1mag = vmag(v1);
      if (v1mag === 0) {
        // fallback tries
        u = vec(0, 1, 0);
        v1 = vcross(u, N);
        v1mag = vmag(v1);
        if (v1mag === 0) {
          u = vec(0, 0, 1);
          v1 = vcross(u, N);
          v1mag = vmag(v1);
          if (v1mag === 0) return;
        }
      }
      v1 = vmul(v1, 1 / v1mag);
      let v2 = vcross(N, v1);
      let v2mag = vmag(v2);
      if (v2mag === 0) return;
      v2 = vmul(v2, 1 / v2mag);

      // Size to cover the lattice (tweakable)
      let size = Math.max(numCells * a * 2, 6.0);

      // Quad corners (plane patch)
      let p0 = vadd(pointOnPlane, vadd(vmul(v1, size), vmul(v2, size)));
      let p1 = vadd(pointOnPlane, vadd(vmul(v1, -size), vmul(v2, size)));
      let p2 = vadd(pointOnPlane, vadd(vmul(v1, -size), vmul(v2, -size)));
      let p3 = vadd(pointOnPlane, vadd(vmul(v1, size), vmul(v2, -size)));

      // Create plane quad with vertex objects
      planeObj = quad({
        v0: vertex({ pos: p0, color: color.yellow, opacity: 0.45 }),
        v1: vertex({ pos: p1, color: color.yellow, opacity: 0.45 }),
        v2: vertex({ pos: p2, color: color.yellow, opacity: 0.45 }),
        v3: vertex({ pos: p3, color: color.yellow, opacity: 0.45 }),
      });

      // Label the plane at its center
      let center = vmul(vadd(vadd(p0, p1), vadd(p2, p3)), 0.25);
      label({
        pos: center,
        text: `(${h},${k},${l})`,
        color: color.yellow,
        box: false,
        opacity: 0.9,
        xoffset: 12,
        yoffset: -8,
      });
    }

    // expose for debugging if needed
    window.createSC = createSC;
    window.createBCC = createBCC;
    window.createFCC = createFCC;
    window.clearAtoms = clearAtoms;
    window.drawPlane = drawPlane;
    window.clearPlane = clearPlane;

    // UI handlers
    $('#createBtn').click(() => {
      let crystalType = $('#crystalType').val();
      let numCells = parseInt($('#numCells').val());
      if (isNaN(numCells) || numCells < 1 || numCells > 12) {
        alert('Please enter a valid number of unit cells (1–12).');
        return;
      }
      if (crystalType === 'sc') createSC(numCells);
      else if (crystalType === 'bcc') createBCC(numCells);
      else if (crystalType === 'fcc') createFCC(numCells);
      clearPlane();
      $('#planeError').hide();
    });

    $('#drawPlaneBtn').click(() => {
      let hStr = $('#hIndex').val();
      let kStr = $('#kIndex').val();
      let lStr = $('#lIndex').val();

      let h = parseFraction(hStr);
      let k = parseFraction(kStr);
      let l = parseFraction(lStr);

      if ([h, k, l].some(v => isNaN(v))) {
        $('#planeError').text('Invalid Miller indices: Use integers, negatives or fractions like 1/2.').show();
        return;
      }
      if (h === 0 && k === 0 && l === 0) {
        $('#planeError').text('Miller indices cannot all be zero.').show();
        return;
      }
      $('#planeError').hide();

      let numCells = parseInt($('#numCells').val());
      drawPlane(h, k, l, latticeA, numCells);
    });

    $('#clearBtn').click(() => {
      clearAtoms();
      clearPlane();
      $('#planeError').hide();
    });

    // initially create a small SC lattice so user sees something
    createSC(parseInt($('#numCells').val() || 3));
  }

  $(function () {
    // attach glowscript canvas to our div
    window.__context = { glowscript_container: $("#glowscript").removeAttr("id") };
    __main__();
  });
})();
</script>
</body>
</html>
